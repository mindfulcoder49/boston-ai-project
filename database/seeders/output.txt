Contents of ./ThreeOneOneSeeder.php:
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class ThreeOneOneSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run(): void
    {
        $name = '311-service-requests'; // Specify the file naming convention to look for
        $files = Storage::disk('local')->files('datasets'); // Fetch all files from 'datasets' directory

        // Filter files to match the specified naming convention
        $files = array_filter($files, function ($file) use ($name) {
            return strpos($file, $name) !== false;
        });

        // Only proceed if there are any files to process
        if (!empty($files)) {
            $file = end($files); // Process the most recent file
            echo "Processing file: " . $file . "\n";
            $this->processFile(Storage::path($file));
        } else {
            echo "No files found to process for name: " . $name . "\n";
        }
    }

    /**
     * Process the file and insert data into the database.
     *
     * @param string $filePath
     * @return void
     */
    private function processFile(string $filePath): void
    {
        if (!file_exists($filePath)) {
            echo "File not found: $filePath\n";
            return;
        }

        // Read and decode the file content (assuming CSV)
        $rows = array_map('str_getcsv', file($filePath));
        $header = array_shift($rows); // Extract header row

        foreach ($rows as $index => $row) {
            try {
                // Combine header and row data into an associative array
                $rowData = array_combine($header, $row);

                // Validate and clean the data
                $cleanedData = $this->validateAndCleanData($rowData);

                // Insert cleaned data into the database
                DB::table('three_one_one_cases')->insert($cleanedData);
            } catch (\Exception $e) {
                // Log errors without interrupting the seeding process
                Log::error("Error processing row $index in file $filePath: " . $e->getMessage());
            }
        }
    }

    /**
     * Validate and clean data for insertion.
     *
     * @param array $row
     * @return array
     * @throws \Exception
     */
    private function validateAndCleanData(array $row): array
    {
        return [
            'case_enquiry_id' => $this->validateInteger($row['case_enquiry_id'] ?? null, 'case_enquiry_id'),
            'open_dt' => $this->validateDateTime($row['open_dt'] ?? null),
            'sla_target_dt' => $row['sla_target_dt'] ?? null,
            'closed_dt' => $this->validateDateTime($row['closed_dt'] ?? null),
            'on_time' => $row['on_time'] ?? null,
            'case_status' => $row['case_status'] ?? null,
            'closure_reason' => $row['closure_reason'] ?? null,
            'case_title' => $row['case_title'] ?? null,
            'subject' => $row['subject'] ?? null,
            'reason' => $row['reason'] ?? null,
            'type' => $row['type'] ?? null,
            'queue' => $row['queue'] ?? null,
            'department' => $row['department'] ?? null,
            'submitted_photo' => $row['submitted_photo'] ?? null,
            'closed_photo' => $row['closed_photo'] ?? null,
            'location' => $row['location'] ?? null,
            'fire_district' => $row['fire_district'] ?? null,
            'pwd_district' => $row['pwd_district'] ?? null,
            'city_council_district' => $row['city_council_district'] ?? null,
            'police_district' => $row['police_district'] ?? null,
            'neighborhood' => $row['neighborhood'] ?? null,
            'neighborhood_services_district' => $row['neighborhood_services_district'] ?? null,
            'ward' => $row['ward'] ?? null,
            'precinct' => $row['precinct'] ?? null,
            'location_street_name' => $row['location_street_name'] ?? null,
            'location_zipcode' => $this->validateDouble($row['location_zipcode'] ?? null),
            'latitude' => $this->validateDouble($row['latitude'] ?? null),
            'longitude' => $this->validateDouble($row['longitude'] ?? null),
            'source' => $row['source'] ?? null,
            'checksum' => $row['checksum'] ?? null,
            'ward_number' => $row['ward_number'] ?? null,
            'language_code' => 'en-US',
        ];
    }

    /**
     * Validation helpers for integer, double, and datetime remain the same.
     */
    private function validateInteger($value, string $field): ?int
    {
        if (is_null($value)) {
            return null;
        }
        if (!is_numeric($value) || intval($value) != $value) {
            throw new \Exception("Invalid integer for $field: $value");
        }
        return intval($value);
    }

    private function validateDouble($value): ?float
    {
        if (is_null($value)) {
            return null;
        }
        if (!is_numeric($value)) {
            throw new \Exception("Invalid double value: $value");
        }
        return floatval($value);
    }

    private function validateDateTime($value): ?string
    {
        if (is_null($value)) {
            return null;
        }
        $date = date_create($value);
        if (!$date) {
            throw new \Exception("Invalid datetime value: $value");
        }
        return $date->format('Y-m-d H:i:s');
    }
}

Contents of ./PropertyViolationsSeeder.php:
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\PropertyViolation;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;
use League\Csv\Reader;


class PropertyViolationsSeeder extends Seeder
{
    private const BATCH_SIZE = 500;

    public function run()
    {
        $name = 'property-violations';
        // Get all files from the datasets folder in Storage
        $files = Storage::disk('local')->files('datasets');

        // Filter files to only include those with the specified name in the filename
        $files = array_filter($files, function ($file) use ($name) {
            return strpos($file, $name) !== false;
        });

        // Only proceed if there are any files to process
        if (!empty($files)) {
            // Get the most recent file
            $file = end($files);
            echo "Processing file: " . $file . "\n";

            // Process the most recent file
            $this->processFile(Storage::path($file));
        } else {
            echo "No files found to process for name: " . $name . "\n";
        }
    }

    private function processFile($filePath)
    {
        try {
            $csv = Reader::createFromPath($filePath, 'r');
            $csv->setHeaderOffset(0); // The header is on the first row
             //set the escape character to null
             $csv->setEscape('');

            $records = $csv->getRecords();

            $dataBatch = [];
            $progress = 0;
            
            foreach ($records as $violation) {
                $progress++;
                 //echo $case_no, description etc, on one line
                echo "Case No: " . $violation['case_no'] . " Description: " . $violation['description'] . "\n";

                // Check and format datetime fields
                $statusDttm = $this->formatDate($violation['status_dttm']);

                //convert empty strings to null
                foreach ($violation as $key => $value) {
                    if ($value === '') {
                        $violation[$key] = null;
                    }
                }

                // Add data to batch array
                $dataBatch[] = [
                    'case_no' => $violation['case_no'],
                    'ap_case_defn_key' => $violation['ap_case_defn_key'],
                    'status_dttm' => $statusDttm,
                    'status' => $violation['status'],
                    'code' => $violation['code'],
                    'value' => $violation['value'],
                    'description' => $violation['description'],
                    'violation_stno' => $violation['violation_stno'],
                    'violation_sthigh' => $violation['violation_sthigh'],
                    'violation_street' => $violation['violation_street'],
                    'violation_suffix' => $violation['violation_suffix'],
                    'violation_city' => $violation['violation_city'],
                    'violation_state' => $violation['violation_state'],
                    'violation_zip' => $violation['violation_zip'],
                    'ward' => $violation['ward'],
                    'contact_addr1' => $violation['contact_addr1'],
                    'contact_addr2' => $violation['contact_addr2'],
                    'contact_city' => $violation['contact_city'],
                    'contact_state' => $violation['contact_state'],
                    'contact_zip' => $violation['contact_zip'],
                    'sam_id' => $violation['sam_id'],
                    'latitude' => $violation['latitude'],
                    'longitude' => $violation['longitude'],
                    'location' => $violation['location'],
                    'language_code' => 'en-US',
                ];
                
                if ($progress % self::BATCH_SIZE == 0) {
                    $this->insertOrUpdateBatch($dataBatch);
                    $dataBatch = []; // Reset the batch
                }
            }

            // Process any remaining data
            if (!empty($dataBatch)) {
                $this->insertOrUpdateBatch($dataBatch);
            }

            echo "File processed: " . basename($filePath) . "\n";
        } catch (\Exception $e) {
            echo "Error processing file: " . basename($filePath) . " - " . $e->getMessage() . "\n";
        }
    }

    private function formatDate($date)
    {
           if (empty($date)) {
            // Set to null or a default value that makes sense for your application
            return null;
        }

         if ( $date == '1970-01-01 00:00:00') {
            echo "Date is 1970-01-01 00:00:00\n";
            return null;
        }
        
        //if date is before epoch time, set to null
        if (strtotime($date) < 0) {
            echo "Date is before epoch time\n";
            return null;
        }
        
         // Ensure date is in the correct format
        $formattedDate = date('Y-m-d H:i:s', strtotime($date));

        return $formattedDate;
    }

    private function insertOrUpdateBatch(array $dataBatch): void
    {
        DB::table((new PropertyViolation)->getTable())->upsert($dataBatch, ['case_no'], [
            'ap_case_defn_key', 'status_dttm', 'status', 'code', 'value', 'description',
            'violation_stno', 'violation_sthigh', 'violation_street', 'violation_suffix',
            'violation_city', 'violation_state', 'violation_zip', 'ward', 'contact_addr1',
            'contact_addr2', 'contact_city', 'contact_state', 'contact_zip', 'sam_id',
             'latitude', 'longitude', 'location', 'language_code'
        ]);
    }
}
Contents of ./ConstructionOffHoursSeeder.php:
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\ConstructionOffHour;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use League\Csv\Reader;

class ConstructionOffHoursSeeder extends Seeder
{
    private const BATCH_SIZE = 500;

    private $suffixMap = [
        'av' => 'ave',
        'bl' => 'blvd',
        'pk' => 'park',
        'pw' => 'pkwy',
        'wy' => 'way',
        'te' => 'ter',
        'pz' => 'plz',
        'hw' => 'hwy',
        'ci' => 'cir',
    ];

    public function run()
    {
        $name = 'construction-off-hours';

        Log::info('Starting ConstructionOffHoursSeeder.');

        // Get files with the specified name in the filename
        $files = Storage::disk('local')->files('datasets');
        $files = array_filter($files, fn($file) => strpos($file, $name) !== false);

        if (!empty($files)) {
            $file = end($files); // Get the most recent file
            Log::info("Found " . count($files) . " files. Processing the most recent file: {$file}");
            $this->processFile(Storage::path($file));
        } else {
            Log::warning("No files found matching the name: '{$name}'.");
        }

        Log::info('ConstructionOffHoursSeeder completed.');
    }

    private function processFile($file)
    {
        try {
            $csv = Reader::createFromPath($file);
            $csv->setHeaderOffset(0);

            $records = $csv->getRecords();
            $dataBatch = [];
            $progress = 0;
            $skipped = 0;

            //sort the records by date
            $records = collect(iterator_to_array($records))->sortBy('start_datetime');

            //remove any older than 60 days ago
            $records = $records->filter(function ($record) {
                return strtotime($record['start_datetime']) > strtotime('-30 days');
            });

            foreach ($records as $offHour) {
                $progress++;

                // Log progress at intervals
                if ($progress % 100 === 0) {
                    Log::info("Progress: {$progress} records processed.");
                }

                // Validate record
                if (empty($offHour['app_no']) || empty($offHour['start_datetime']) || empty($offHour['address'])) {
                    $skipped++;
                    Log::warning("Skipping invalid record at row {$progress}: " . json_encode($offHour));
                    continue;
                }

                // Extract and normalize the base address
                $baseAddress = $this->normalizeAddress($offHour['address']);

                // Find the best matching address dynamically
                $bestMatch = $this->findMatchDynamically($baseAddress);

                // Fallback: Try substring after hyphen if no match found
                if (!$bestMatch && str_contains($baseAddress, '-')) {
                    $afterHyphen = $this->getSubstringAfterHyphen($baseAddress);
                    Log::info("No match found for normalized address: '{$baseAddress}'. Trying after hyphen: '{$afterHyphen}'");
                    $bestMatch = $this->findMatchDynamically($afterHyphen);

                    if ($bestMatch) {
                        Log::info("Fallback match for row {$progress}: '{$baseAddress}' -> '{$afterHyphen}' -> '{$bestMatch->full_address}'");
                    }
                }

                if (!$bestMatch) {
                    $skipped++;
                    Log::warning("No match found for normalized address: '{$baseAddress}' (original: '{$offHour['address']}')");
                    continue;
                }

                // Log matched address details
                Log::info("Matched address for row {$progress}: '{$offHour['address']}' -> '{$bestMatch->full_address}'");

                //if stop_datetime is empty, set it to start_datetime
                if (empty($offHour['stop_datetime'])) {
                    $offHour['stop_datetime'] = $offHour['start_datetime'];
                }

                $dataBatch[] = [
                    'app_no' => $offHour['app_no'],
                    'start_datetime' => $offHour['start_datetime'],
                    'stop_datetime' => $offHour['stop_datetime'],
                    'address' => $offHour['address'],
                    'ward' => $offHour['ward'],
                    'latitude' => $bestMatch->latitude,
                    'longitude' => $bestMatch->longitude,
                    'language_code' => 'en-US',
                ];

                if ($progress % self::BATCH_SIZE == 0) {
                    $this->insertOrUpdateBatch($dataBatch);
                    $dataBatch = [];
                    Log::info("Inserted batch of " . self::BATCH_SIZE . " records. Progress: {$progress}");
                }
            }

            if (!empty($dataBatch)) {
                $this->insertOrUpdateBatch($dataBatch);
                Log::info("Inserted final batch of " . count($dataBatch) . " records.");
            }

            Log::info("Finished processing file: {$file}. Total processed: {$progress}, Skipped: {$skipped}");
        } catch (\Exception $e) {
            Log::error("Error processing file: {$file}. Exception: " . $e->getMessage());
        }
    }

    private function normalizeAddress($address)
    {
        $parts = explode(',', $address, 2);
        $baseAddress = strtolower(trim($parts[0]));

        // Replace suffixes using the suffix map
        foreach ($this->suffixMap as $short => $full) {
            $baseAddress = preg_replace('/\b' . $short . '\b/', $full, $baseAddress);
        }

        return $baseAddress;
    }

    private function getSubstringAfterHyphen($address)
    {
        $parts = explode('-', $address, 2);
        return isset($parts[1]) ? trim($parts[1]) : $address;
    }

    private function findMatchDynamically($normalizedAddress)
    {
        return DB::table('trash_schedules_by_address')
            ->whereRaw('LOWER(full_address) = ?', [$normalizedAddress])
            ->select('full_address', 'y_coord as latitude', 'x_coord as longitude')
            ->first();
    }

    private function insertOrUpdateBatch(array $dataBatch): void
    {
        try {
            DB::table((new ConstructionOffHour)->getTable())->upsert($dataBatch, ['app_no', 'start_datetime', 'stop_datetime', 'language_code'], [
                'address', 'ward', 'latitude', 'longitude'
            ]);
            Log::info("Batch upsert completed with " . count($dataBatch) . " records.");
        } catch (\Exception $e) {
            Log::error("Error during batch upsert: " . $e->getMessage());
        }
    }
}

Contents of ./DatabaseSeeder.php:
<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        $this->call([
            TrashSchedulesByAddressSeeder::class,
            CrimeDataSeeder::class,
            ThreeOneOneSeeder::class,
            BuildingPermitsSeeder::class,
            PropertyViolationsSeeder::class,
            ConstructionOffHoursSeeder::class,
        ]);
    }
}

Contents of ./BuildingPermitsSeeder.php:
<?php

// database/seeders/BuildingPermitsSeeder.php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\BuildingPermit;
use Illuminate\Support\Facades\File;
use League\Csv\Reader;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;

class BuildingPermitsSeeder extends Seeder
{
    private const BATCH_SIZE = 500;

    public function run()
    {
        $name = 'building-permits';
        // Get all files from the datasets folder in Storage
        $files = Storage::disk('local')->files('datasets');

        // Filter files to only include those with the specified name in the filename
        $files = array_filter($files, function ($file) use ($name) {
            return strpos($file, $name) !== false;
        });

        // Only proceed if there are any files to process
        if (!empty($files)) {
            // Get the most recent file
            $file = end($files);
            echo "Processing file: " . $file . "\n";

            // Process the most recent file
            $this->processFile(Storage::path($file));
        } else {
            echo "No files found to process for name: " . $name . "\n";
        }
    }

    private function processFile($filePath)
    {
        try {
            $csv = Reader::createFromPath($filePath, 'r');
            $csv->setHeaderOffset(0); // The header is on the first row
            //set the escape character to null
            $csv->setEscape('');

            $records = $csv->getRecords();

            $dataBatch = [];
            $progress = 0;

            foreach ($records as $permit) {
                $progress++;
                //echo $date, permit number, etc, on one line
                echo "SqFt contains: " . $permit['sq_feet'] . " Permit number: " . $permit['permitnumber'] . "\n";
                // Check and format datetime fields
                $issuedDate = $this->formatDate($permit['issued_date']);
                $expirationDate = $this->formatDate($permit['expiration_date']);

                //check sq_feet and convert to integer if it is a number, otherwise set to 0
                $sqfeet = is_numeric($permit['sq_feet']) ? (int)$permit['sq_feet'] : 0;

                //set it to a maximum of one billion
                if ($sqfeet > 1000000000) {
                    $sqfeet = 1000000000;
                }



                //convert empty strings to null
                foreach ($permit as $key => $value) {
                    if ($value === '') {
                        $permit[$key] = null;
                    }
                }

                // Add data to batch array
                $dataBatch[] = [
                    'permitnumber' => $permit['permitnumber'],
                    'worktype' => $permit['worktype'],
                    'permittypedescr' => $permit['permittypedescr'],
                    'description' => $permit['description'],
                    'comments' => $permit['comments'],
                    'applicant' => $permit['applicant'],
                    'declared_valuation' => $permit['declared_valuation'],
                    'total_fees' => $permit['total_fees'],
                    'issued_date' => $issuedDate,
                    'expiration_date' => $expirationDate,
                    'status' => $permit['status'],
                    'occupancytype' => $permit['occupancytype'],
                    'sq_feet' => $sqfeet,
                    'address' => $permit['address'],
                    'city' => $permit['city'],
                    'state' => $permit['state'],
                    'zip' => $permit['zip'],
                    'property_id' => $permit['property_id'],
                    'parcel_id' => $permit['parcel_id'],
                    'gpsy' => $permit['gpsy'],
                    'gpsx' => $permit['gpsx'],
                    'y_latitude' => $permit['y_latitude'],
                    'x_longitude' => $permit['x_longitude'],
                    'language_code' => 'en-US',
                ];

                if ($progress % self::BATCH_SIZE == 0) {
                    $this->insertOrUpdateBatch($dataBatch);
                    $dataBatch = []; // Reset the batch
                }
            }

            // Process any remaining data
            if (!empty($dataBatch)) {
                $this->insertOrUpdateBatch($dataBatch);
            }

            echo "File processed: " . basename($filePath) . "\n";
        } catch (\Exception $e) {
            echo "Error processing file: " . basename($filePath) . " - " . $e->getMessage() . "\n";
        }
    }

    private function formatDate($date)
    {

        if (empty($date)) {
            // Set to null or a default value that makes sense for your application
            return null;
        }

        if ( $date == '1970-01-01 00:00:00') {
            echo "Date is 1970-01-01 00:00:00\n";
            return null;
        }

        //if date is before epoch time, set to null
        if (strtotime($date) < 0) {
            echo "Date is before epoch time\n";
            return null;
        }

        
        // Ensure date is in the correct format
        $formattedDate = date('Y-m-d H:i:s', strtotime($date));

        return $formattedDate;
    }
        

    private function insertOrUpdateBatch(array $dataBatch): void
    {
        DB::table((new BuildingPermit)->getTable())->upsert($dataBatch, ['permitnumber'], [
            'worktype', 'permittypedescr', 'description', 'comments', 'applicant', 
            'declared_valuation', 'total_fees', 'issued_date', 'expiration_date', 
            'status', 'occupancytype', 'sq_feet', 'address', 'city', 'state', 'zip', 
            'property_id', 'parcel_id', 'gpsy', 'gpsx', 'y_latitude', 'x_longitude', 'language_code'
        ]);
    }

    private function parseFloat($value)
    {
        // Return float value or null if the value is not numeric
        return is_numeric($value) ? (float)$value : null;
    }
}

Contents of ./output.txt:

Contents of ./LabelsSeeder.php:
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\Log;
use App\Models\Label;
use App\Services\OpenAIService;

class LabelTranslationSeeder extends Seeder
{
    protected $aiService;

    public function __construct()
    {
        $this->aiService = app(OpenAIService::class); // Inject your AI service
    }

    public function run()
    {
        Log::info('Starting LabelTranslationSeeder...');

        try {
            // Fetch all English labels
            $englishLabels = Label::where('language_code', 'en')->get();

            if ($englishLabels->isEmpty()) {
                Log::warning('No English labels found to translate.');
                return;
            }

            Log::info('Fetched English labels', ['count' => $englishLabels->count()]);

            // Prepare the AI function definition
            $functionDefinition = [
                "name" => "store_translated_labels",
                "description" => "Translates a set of labels into the specified language.",
                "parameters" => [
                    "type" => "object",
                    "properties" => [
                        "labels" => [
                            "type" => "array",
                            "items" => [
                                "type" => "object",
                                "properties" => [
                                    "code_name" => ["type" => "string", "description" => "The label's code name."],
                                    "text" => ["type" => "string", "description" => "The label's text in English."],
                                    "language_code" => ["type" => "string", "description" => "The target language code for translation."],
                                ],
                                "required" => ["code_name", "text", "language_code"]
                            ]
                        ]
                    ],
                    "required" => ["labels"]
                ]
            ];

            // Iterate over chunks of 10 labels for translation
            foreach ($englishLabels->chunk(10) as $chunk) {
                $labelsToTranslate = $chunk->map(function ($label) {
                    return [
                        "code_name" => $label->code_name,
                        "text" => $label->text,
                        "language_code" => 'es', // Example: translating to Spanish
                    ];
                })->toArray();

                // Prompt the AI
                $prompt = "Translate these English labels into Spanish (language code 'es'):\n" . json_encode($labelsToTranslate, JSON_PRETTY_PRINT);

                $systemMessage = "You are a translation assistant responsible for translating application labels into different languages.";

                $translatedLabels = $this->aiService->callFunction($functionDefinition, $prompt, $systemMessage);

                // Insert translated labels into the database
                foreach ($translatedLabels['labels'] as $translatedLabel) {
                    Label::create([
                        'code_name' => $translatedLabel['code_name'],
                        'text' => $translatedLabel['text'],
                        'language_code' => $translatedLabel['language_code'],
                    ]);

                    Log::info("Inserted translated label", ['code_name' => $translatedLabel['code_name'], 'language_code' => $translatedLabel['language_code']]);
                }
            }

            Log::info('LabelTranslationSeeder completed.');
        } catch (\Exception $e) {
            Log::error('Failed to seed translated labels', ['exception' => $e]);
        }
    }
}

Contents of ./Api311Seeder.php:
<?php

use Illuminate\Database\Seeder;
use App\Models\Boston311Data;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\RequestException;
use Carbon\Carbon;
use Carbon\CarbonInterval;

class Api311Seeder extends Seeder
{
    public function run()
    {
        $client = new Client();
        $startDate = $this->getLastDateInDB() ?? Carbon::create(2023, 1, 1, 0, 0, 0, 'UTC');
        $endDate = Carbon::create(2023, 9, 20, 0, 0, 0, 'UTC');
        $dayDelta = CarbonInterval::days(1);
        $minuteDelta = CarbonInterval::minutes(1);

        while ($startDate->lessThanOrEqualTo($endDate)) {
            $formattedStartDate = $startDate->toIso8601String();
            $formattedEndDate = $startDate->copy()->add($dayDelta)->toIso8601String();

            try {
                $response = $client->get("https://311.boston.gov/open311/v2/requests.json?start_date=$formattedStartDate&end_date=$formattedEndDate");

                if ($response->getStatusCode() === 200) {
                    $data = json_decode($response->getBody(), true);
                    echo "Number of requests: " . count($data) . "\n";

                    foreach ($data as $record) {
                        Boston311Data::updateOrInsert(
                            ['service_request_id' => $record['service_request_id']],
                            $record
                        );
                    }

                    if (count($data) > 0) {
                        $lastDate = Carbon::parse($data[array_key_last($data)]['requested_datetime']);
                        if ($lastDate->greaterThan($startDate)) {
                            $startDate = $lastDate;
                        } else {
                            $startDate->add($minuteDelta);
                        }
                    } else {
                        $startDate->add($dayDelta);
                    }
                }
            } catch (RequestException $e) {
                echo "Failed to fetch data for $formattedStartDate to $formattedEndDate\n";
            } catch (JsonException $e) {
                echo "Failed to decode JSON for $formattedStartDate to $formattedEndDate\n";
            }

            sleep(6);  // Rate limiting
        }
    }

    private function getLastDateInDB()
    {
        $record = Boston311Data::latest('requested_datetime')->first();
        return $record ? Carbon::parse($record->requested_datetime) : null;
    }
}

Contents of ./CrimeDataSeeder.php:
<?php

// database/seeders/CrimeDataSeeder.php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\CrimeData;
use Illuminate\Support\Facades\File;
use League\Csv\Reader;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;

class CrimeDataSeeder extends Seeder
{
    private const BATCH_SIZE = 500;

    public function run()
    {
        $name = 'crime-incident-reports';
        // Get all files from the datasets folder in Storage
        $files = Storage::disk('local')->files('datasets');

        // Filter files to only include those with the specified name in the filename
        $files = array_filter($files, function ($file) use ($name) {
            return strpos($file, $name) !== false;
        });

        // Only proceed if there are any files to process
        if (!empty($files)) {
            // Get the most recent file
            $file = end($files);
            echo "Processing file: " . $file . "\n";

            // Process the most recent file
            $this->processFile(Storage::path($file));
        } else {
            echo "No files found to process for name: " . $name . "\n";
        }
    }

    private function processFile($file)
    {
        print_r("Processing file: " . $file . "\n");
        $csv = Reader::createFromPath($file);
        $csv->setHeaderOffset(0); // The header is on the first row

        $records = $csv->getRecords();

        $dataBatch = [];
        $progress = 0;
        $startTime = microtime(true);
        $fileCount = count(file($file));
        $skipped = 0;

        foreach ($records as $crime) {
            $progress++;

            if (!is_numeric($crime['Lat']) || !is_numeric($crime['Long'])) {
                print_r("Skipping record with invalid lat/long: " . $crime['Lat'] . ", " . $crime['Long'] . "\n");
                $skipped++;
                continue;
            } else {
                print_r("Processing record with lat/long: " . $crime['Lat'] . ", " . $crime['Long'] . "\n");
            }

            $occurred_on_date = $this->formatDate($crime['OCCURRED_ON_DATE']);

            $dataBatch[] = [
                'incident_number' => $crime['INCIDENT_NUMBER'],
                'offense_code' => $crime['OFFENSE_CODE'],
                'offense_code_group' => $crime['OFFENSE_CODE_GROUP'],
                'offense_description' => $crime['OFFENSE_DESCRIPTION'],
                'district' => $crime['DISTRICT'],
                'reporting_area' => $crime['REPORTING_AREA'],
                'shooting' => $crime['SHOOTING'] == 'Y',
                'occurred_on_date' => $occurred_on_date,
                'year' => $crime['YEAR'],
                'month' => $crime['MONTH'],
                'day_of_week' => $crime['DAY_OF_WEEK'],
                'hour' => $crime['HOUR'],
                'ucr_part' => $crime['UCR_PART'],
                'street' => $crime['STREET'],
                'lat' => $crime['Lat'],
                'long' => $crime['Long'],
                'location' => $crime['Location'],
                'language_code' => 'en-US'
            ];

            if ($progress % self::BATCH_SIZE == 0) {
                $this->insertOrUpdateBatch($dataBatch);
                $dataBatch = []; // Reset the batch

                // Progress reporting
                $endTime = microtime(true);
                $timeTaken = $endTime - $startTime;
                $this->reportProgress($progress, $fileCount, $timeTaken);
                $startTime = microtime(true);
            }
        }

        // Process any remaining data
        if (!empty($dataBatch)) {
            $this->insertOrUpdateBatch($dataBatch);
        }

        print_r("File processed: " . $file . "\n");
    }

    private function insertOrUpdateBatch(array $dataBatch): void
    {
        DB::table((new CrimeData)->getTable())->upsert($dataBatch, ['incident_number'], [
            'offense_code',
            'offense_code_group',
            'offense_description',
            'district',
            'reporting_area',
            'shooting',
            'occurred_on_date',
            'year',
            'month',
            'day_of_week',
            'hour',
            'ucr_part',
            'street',
            'lat',
            'long',
            'location',
            'language_code'
        ]);
    }

    private function reportProgress($progress, $fileCount, $timeTaken)
    {
        $estimatedTimePerRecord = $timeTaken / self::BATCH_SIZE;
        $estimatedTimeRemainingFile = $estimatedTimePerRecord * ($fileCount - $progress);
        
        // Clear the previous 5 lines
        echo "\033[5A";  // Move 5 lines up
        echo "\033[K";   // Clear current line
        echo $progress . " records processed.\n";
        echo "\033[K";   // Clear current line
        echo "Records remaining in this file: " . ($fileCount - $progress) . ".\n";
        echo "\033[K";   // Clear current line
        echo "Time for last " . self::BATCH_SIZE . " records: " . round($timeTaken, 2) . " seconds.\n";
        echo "\033[K";   // Clear current line
        echo "Estimated time remaining for this file: " . $this->formatTime($estimatedTimeRemainingFile) . ".\n";
    }

    private function formatTime(float $timeInSeconds): string
    {
        $hours = floor($timeInSeconds / 3600);
        $minutes = floor(($timeInSeconds % 3600) / 60);
        $seconds = $timeInSeconds % 60;

        $formattedTime = [];
        if ($hours > 0) {
            $formattedTime[] = $hours . ' hour' . ($hours > 1 ? 's' : '');
        }
        if ($minutes > 0 || $hours > 0) {
            $formattedTime[] = $minutes . ' minute' . ($minutes > 1 ? 's' : '');
        }
        $formattedTime[] = round($seconds, 2) . ' second' . ($seconds != 1 ? 's' : '');

        return implode(', ', $formattedTime);
    }

    private function formatDate($date)
    {
        // Strip timezone offset
        if (strpos($date, '+') !== false) {
            $date = explode('+', $date)[0];
        } elseif (strpos($date, '-') !== false) {
            $date = explode('-', $date)[0];
        }

        // Convert to datetime
        return date('Y-m-d H:i:s', strtotime($date));
    }
}

Contents of ./TransformedTranslationsSeeder.php:
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use App\Models\ThreeOneOneCase;
use App\Models\CrimeData;
use App\Models\BuildingPermit;
use App\Models\ConstructionOffHour;
use App\Models\PropertyViolation;

class TransformedTranslationsSeeder extends Seeder
{
    private const BATCH_SIZE = 500;

    public function run()
    {
        $filePath = 'batches/transformed_translations.jsonl';

        if (!Storage::disk('local')->exists($filePath)) {
            Log::error("Transformed translations file not found: {$filePath}");
            return;
        }

        $lines = explode("\n", Storage::disk('local')->get($filePath));
        $batchData = [];
        $progress = 0;

        foreach ($lines as $line) {
            if (empty($line)) {
                continue;
            }

            $record = json_decode($line, true);
            if (json_last_error() !== JSON_ERROR_NONE) {
                Log::error("Failed to parse line: {$line}");
                continue;
            }

            $modelClass = $this->getModelClass($record);
            if (!$modelClass) {
                Log::error("Unknown model for record: " . json_encode($record));
                continue;
            }

            if (isset($record['occurred_on_date'])) {
                $record['occurred_on_date'] = $this->formatDate($record['occurred_on_date']);
            }

            $batchData[$modelClass][] = $record;

            if (count($batchData[$modelClass]) >= self::BATCH_SIZE) {
                $this->insertBatch($modelClass, $batchData[$modelClass]);
                $batchData[$modelClass] = [];
                $progress += self::BATCH_SIZE;
                echo "Processed {$progress} records...\n"; // Replaced $this->info with echo
            }
        }

        // Insert remaining records
        foreach ($batchData as $modelClass => $data) {
            if (!empty($data)) {
                $this->insertBatch($modelClass, $data);
            }
        }

        echo "All records processed and inserted.\n"; // Replaced $this->info with echo
    }

    private function insertBatch(string $modelClass, array $dataBatch): void
    {
        try {
            $tableName = (new $modelClass)->getTable();
            $uniqueKeys = [$modelClass::getExternalIdName(), 'language_code'];

            DB::table($tableName)->upsert(
                $dataBatch,
                $uniqueKeys,
                array_keys($dataBatch[0]) // Update all columns except unique keys
            );

            Log::info("Batch inserted successfully for {$modelClass}.", ['count' => count($dataBatch)]);
        } catch (\Exception $e) {
            Log::error("Failed batch insert for {$modelClass}: " . $e->getMessage());
        }
    }

    private function getModelClass(array $record): ?string
    {
        if (isset($record['case_enquiry_id'])) {
            return ThreeOneOneCase::class;
        } elseif (isset($record['incident_number'])) {
            return CrimeData::class;
        } elseif (isset($record['permitnumber'])) {
            return BuildingPermit::class;
        } elseif (isset($record['app_no'])) {
            return ConstructionOffHour::class;
        } elseif (isset($record['case_no'])) {
            return PropertyViolation::class;
        }

        return null; // Unknown model
    }

    private function formatDate(string $date): ?string
    {
        try {
            return \Carbon\Carbon::parse($date)->format('Y-m-d H:i:s');
        } catch (\Exception $e) {
            Log::error("Invalid date format: {$date}");
            return null;
        }
    }

}

Contents of ./TrashSchedulesByAddressSeeder.php:
<?php

// database/seeders/TrashSchedulesByAddressSeeder.php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\TrashScheduleByAddress;
use Illuminate\Support\Facades\File;
use League\Csv\Reader;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;

class TrashSchedulesByAddressSeeder extends Seeder
{
    private const BATCH_SIZE = 500;

    public function run()
    {

        $name = 'trash-schedules-by-address';
        // Get all files from the datasets folder in Storage
        $files = Storage::disk('local')->files('datasets');

        // Filter files to only include those with the specified name in the filename
        $files = array_filter($files, function ($file) use ($name) {
            return strpos($file, $name) !== false;
        });

        // Only proceed if there are any files to process
        if (!empty($files)) {
            // Get the most recent file
            $file = end($files);
            echo "Processing file: " . $file . "\n";

            // Process the most recent file
            $this->processFile(Storage::path($file));
        } else {
            echo "No files found to process for name: " . $name . "\n";
        }
    }

    private function processFile($file)
    {
        print_r("Processing file: " . $file . "\n");
        $csv = Reader::createFromPath($file);
        $csv->setHeaderOffset(0); // The header is on the first row

        $records = $csv->getRecords();

        $dataBatch = [];
        $progress = 0;
        $fileCount = count(file($file));
        $skipped = 0;

        foreach ($records as $trashSchedule) {
            $progress++;

            print_r("Processing record: " . $progress . " of " . $fileCount . "\n");

            // Add data to batch array
            $dataBatch[] = [
                'sam_address_id' => $trashSchedule['sam_address_id'],
                'full_address' => $trashSchedule['full_address'],
                'mailing_neighborhood' => $trashSchedule['mailing_neighborhood'],
                'state' => $trashSchedule['state'],
                'zip_code' => $trashSchedule['zip_code'],
                'x_coord' => $trashSchedule['x_coord'],
                'y_coord' => $trashSchedule['y_coord'],
                'recollect' => $trashSchedule['recollect'] == 'T',
                'trashday' => $trashSchedule['trashday'],
                'pwd_district' => $trashSchedule['pwd_district'],
            ];

            if ($progress % self::BATCH_SIZE == 0) {
                $this->insertOrUpdateBatch($dataBatch);
                $dataBatch = []; // Reset the batch
            }
        }

        // Process any remaining data
        if (!empty($dataBatch)) {
            $this->insertOrUpdateBatch($dataBatch);
        }

        print_r("File processed: " . $file . "\n");
    }

    private function insertOrUpdateBatch(array $dataBatch): void
    {
        DB::table((new TrashScheduleByAddress)->getTable())->upsert($dataBatch, ['sam_address_id'], [
            'full_address', 'mailing_neighborhood', 'state', 'zip_code', 'x_coord', 
            'y_coord', 'recollect', 'trashday', 'pwd_district'
        ]);
    }
}

